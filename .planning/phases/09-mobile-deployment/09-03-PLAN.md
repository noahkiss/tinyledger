---
phase: 09-mobile-deployment
plan: 03
type: execute
wave: 2
depends_on: ["09-02"]
files_modified:
  - BACKUP.md
  - src/lib/server/db/backup.ts
autonomous: true

must_haves:
  truths:
    - "Backup documentation explains how to backup databases safely"
    - "Backup documentation explains how to backup attachments"
    - "Restore procedures are documented with verification steps"
    - "Hot backup method uses VACUUM INTO (not file copy)"
  artifacts:
    - path: "BACKUP.md"
      provides: "Complete backup and restore documentation"
      contains: "VACUUM INTO"
      min_lines: 100
    - path: "src/lib/server/db/backup.ts"
      provides: "SQLite backup utility function"
      exports: ["backupDatabase"]
  key_links:
    - from: "BACKUP.md"
      to: "docker-compose.yml"
      via: "references volume locations"
      pattern: "ledger-db|ledger-attachments"
---

<objective>
Document SQLite backup strategy and create backup utility function.

Purpose: Provide clear, tested procedures for backing up and restoring data, ensuring users can protect their financial records without risking corruption.

Output: BACKUP.md with complete backup/restore procedures, backup utility function for programmatic use.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mobile-deployment/09-CONTEXT.md
@.planning/phases/09-mobile-deployment/09-RESEARCH.md
@docker-compose.yml
@src/lib/server/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup utility function</name>
  <files>src/lib/server/db/backup.ts</files>
  <action>
Create `src/lib/server/db/backup.ts` with a utility function for safe SQLite backups:

```typescript
import { getWorkspaceDb } from './index';
import type Database from 'better-sqlite3';

/**
 * Safely backup a workspace database using VACUUM INTO.
 *
 * VACUUM INTO creates a transactionally-consistent backup without
 * blocking writers. This is safe to run on a live database.
 *
 * @param workspaceId - The workspace to backup
 * @param backupPath - Full path for the backup file (must not exist)
 * @throws Error if backup path already exists or backup fails
 */
export function backupDatabase(workspaceId: string, backupPath: string): void {
  const db = getWorkspaceDb(workspaceId);

  // VACUUM INTO requires the target file to not exist
  // It creates a new database file with all data compacted
  db.exec(`VACUUM INTO '${backupPath}'`);
}

/**
 * Backup a database using the better-sqlite3 backup API.
 * This provides progress reporting for large databases.
 *
 * @param workspaceId - The workspace to backup
 * @param backupPath - Full path for the backup file
 * @param onProgress - Optional callback for progress updates
 */
export async function backupDatabaseAsync(
  workspaceId: string,
  backupPath: string,
  onProgress?: (percent: number) => void
): Promise<void> {
  const db = getWorkspaceDb(workspaceId);

  await db.backup(backupPath, {
    progress({ totalPages, remainingPages }) {
      if (onProgress) {
        const percent = ((totalPages - remainingPages) / totalPages) * 100;
        onProgress(Math.round(percent));
      }
      return 200; // pages per iteration
    }
  });
}
```

This module provides:
- `backupDatabase`: Synchronous backup using VACUUM INTO (recommended for small-medium DBs)
- `backupDatabaseAsync`: Async backup with progress reporting (for large DBs)

Both methods are safe to run on a live database without corruption risk.
  </action>
  <verify>
- File exists at src/lib/server/db/backup.ts
- Exports backupDatabase and backupDatabaseAsync functions
- Uses VACUUM INTO for safe hot backup
- `npm run check` passes
  </verify>
  <done>
Backup utility functions exist for safe database backup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BACKUP.md documentation</name>
  <files>BACKUP.md</files>
  <action>
Create `BACKUP.md` at project root with comprehensive backup and restore documentation:

```markdown
# TinyLedger Backup & Restore Guide

This guide covers backup and restore procedures for TinyLedger running in Docker.

## Overview

TinyLedger stores data in two locations:
- **Databases**: SQLite files for each workspace (`/data/db/`)
- **Attachments**: Receipt images and files (`/data/attachments/`)

Both must be backed up to fully restore your data.

## Quick Reference

| Data Type | Location | Backup Method | Frequency |
|-----------|----------|---------------|-----------|
| Databases | `/data/db/*.db` | VACUUM INTO | Daily recommended |
| Attachments | `/data/attachments/` | File copy | After each upload |

---

## Database Backup

### Why VACUUM INTO?

**Never copy SQLite files directly while the app is running.** SQLite uses write-ahead logging (WAL) that may have uncommitted data. Copying the file can result in a corrupted backup.

Use `VACUUM INTO` instead - it creates a transactionally-consistent backup without blocking the application.

### Method 1: Using sqlite3 CLI (Recommended)

From the Docker host:

\`\`\`bash
# Find your database files
docker compose exec app ls /data/db/

# Backup a specific workspace (replace WORKSPACE_ID)
docker compose exec app sqlite3 /data/db/WORKSPACE_ID.db "VACUUM INTO '/data/db/WORKSPACE_ID-backup-$(date +%Y%m%d).db'"

# Copy backup to host
docker cp $(docker compose ps -q app):/data/db/WORKSPACE_ID-backup-*.db ./backups/
\`\`\`

### Method 2: Direct Volume Access

If the container is stopped, you can safely copy files:

\`\`\`bash
# Stop the container first
docker compose stop

# Copy entire db volume
docker run --rm -v ledger-db:/data -v $(pwd)/backups:/backup alpine \
  cp -r /data /backup/db-$(date +%Y%m%d)

# Restart
docker compose start
\`\`\`

### Method 3: Backup All Workspaces

Script to backup all workspaces:

\`\`\`bash
#!/bin/bash
# backup-all.sh
BACKUP_DIR="./backups/$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"

# Get list of all .db files
for db in $(docker compose exec -T app ls /data/db/*.db 2>/dev/null); do
  name=$(basename "$db" .db)
  echo "Backing up $name..."
  docker compose exec -T app sqlite3 "$db" "VACUUM INTO '/data/db/${name}-backup.db'"
  docker cp "$(docker compose ps -q app):/data/db/${name}-backup.db" "$BACKUP_DIR/"
  docker compose exec -T app rm "/data/db/${name}-backup.db"
done

echo "Backups saved to $BACKUP_DIR"
\`\`\`

---

## Attachment Backup

Attachments are regular files and can be copied directly:

\`\`\`bash
# Backup attachments to host
docker run --rm -v ledger-attachments:/data -v $(pwd)/backups:/backup alpine \
  cp -r /data /backup/attachments-$(date +%Y%m%d)
\`\`\`

Or using docker cp:

\`\`\`bash
docker cp $(docker compose ps -q app):/data/attachments ./backups/attachments-$(date +%Y%m%d)
\`\`\`

---

## Full Backup Script

Complete backup script for databases and attachments:

\`\`\`bash
#!/bin/bash
# full-backup.sh
set -e

BACKUP_DIR="./backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR/db" "$BACKUP_DIR/attachments"

echo "Starting TinyLedger backup..."

# Backup databases using VACUUM INTO
echo "Backing up databases..."
for db in $(docker compose exec -T app ls /data/db/*.db 2>/dev/null); do
  name=$(basename "$db" .db)
  echo "  - $name"
  docker compose exec -T app sqlite3 "$db" "VACUUM INTO '/data/db/${name}-backup.db'"
  docker cp "$(docker compose ps -q app):/data/db/${name}-backup.db" "$BACKUP_DIR/db/${name}.db"
  docker compose exec -T app rm "/data/db/${name}-backup.db"
done

# Backup attachments
echo "Backing up attachments..."
docker cp "$(docker compose ps -q app):/data/attachments/." "$BACKUP_DIR/attachments/"

# Create archive
echo "Creating archive..."
tar -czf "$BACKUP_DIR.tar.gz" -C "$(dirname $BACKUP_DIR)" "$(basename $BACKUP_DIR)"
rm -rf "$BACKUP_DIR"

echo "Backup complete: $BACKUP_DIR.tar.gz"
\`\`\`

---

## Restore Procedures

### Restoring a Database

1. **Stop the container** (required for restore):
   \`\`\`bash
   docker compose stop
   \`\`\`

2. **Copy backup to volume**:
   \`\`\`bash
   # Replace WORKSPACE_ID and backup file path
   docker run --rm -v ledger-db:/data -v $(pwd)/backups:/backup alpine \
     cp /backup/WORKSPACE_ID.db /data/db/WORKSPACE_ID.db
   \`\`\`

3. **Restart container**:
   \`\`\`bash
   docker compose start
   \`\`\`

4. **Verify restore**:
   - Open the app and navigate to the workspace
   - Check that transactions and settings are restored

### Restoring Attachments

1. **Stop the container**:
   \`\`\`bash
   docker compose stop
   \`\`\`

2. **Copy attachments to volume**:
   \`\`\`bash
   docker run --rm -v ledger-attachments:/data -v $(pwd)/backups:/backup alpine \
     cp -r /backup/attachments/* /data/attachments/
   \`\`\`

3. **Restart container**:
   \`\`\`bash
   docker compose start
   \`\`\`

4. **Verify restore**:
   - Open a transaction with an attachment
   - Confirm the image loads correctly

### Full Restore from Archive

\`\`\`bash
#!/bin/bash
# restore.sh <backup-archive.tar.gz>
set -e

ARCHIVE="$1"
if [ -z "$ARCHIVE" ]; then
  echo "Usage: ./restore.sh <backup-archive.tar.gz>"
  exit 1
fi

# Extract archive
RESTORE_DIR=$(mktemp -d)
tar -xzf "$ARCHIVE" -C "$RESTORE_DIR"
BACKUP_DIR=$(ls "$RESTORE_DIR")

echo "Stopping TinyLedger..."
docker compose stop

echo "Restoring databases..."
docker run --rm -v ledger-db:/data -v "$RESTORE_DIR/$BACKUP_DIR/db":/backup alpine \
  sh -c "rm -f /data/db/*.db && cp /backup/*.db /data/db/"

echo "Restoring attachments..."
docker run --rm -v ledger-attachments:/data -v "$RESTORE_DIR/$BACKUP_DIR/attachments":/backup alpine \
  sh -c "rm -rf /data/attachments/* && cp -r /backup/* /data/attachments/"

echo "Starting TinyLedger..."
docker compose start

rm -rf "$RESTORE_DIR"
echo "Restore complete. Verify your data in the app."
\`\`\`

---

## Verification Checklist

After restoring, verify:

- [ ] App loads without errors
- [ ] All workspaces appear in dropdown
- [ ] Transactions are present with correct dates and amounts
- [ ] Attachments display correctly (open a transaction with receipt)
- [ ] Reports generate correctly
- [ ] Workspace settings are preserved

---

## Backup Best Practices

1. **Schedule regular backups**: Daily for active use, weekly minimum
2. **Store backups off-site**: Don't keep backups only on the same machine
3. **Test restores periodically**: Verify backups work before you need them
4. **Keep multiple generations**: Retain at least 7 days of backups
5. **Document your schedule**: Know when backups run and where they go

---

## Troubleshooting

### "database is locked" error during backup

The VACUUM INTO command shouldn't lock, but if you see this:
1. Check for hung processes: `docker compose exec app ps aux`
2. Restart container: `docker compose restart`
3. Try backup again

### Backup file is 0 bytes

VACUUM INTO requires the target file to not exist. Check if file already exists:
\`\`\`bash
docker compose exec app ls -la /data/db/
\`\`\`

### Corrupted database after restore

Restore from an older backup. If no valid backup exists:
1. Export data from the app (Settings > Export Full Backup)
2. Create a new workspace
3. Import the exported data

---

## Emergency Recovery

If both database and backups are lost but you have the app's Full Export ZIP:

1. Create a new workspace with the same settings
2. Import transactions from the CSV in the export
3. Manually re-upload attachments (they're in the ZIP's attachments/ folder)

The Full Export feature (Settings > Export Full Backup) is your last-resort recovery option.
\`\`\`

Key sections per CONTEXT.md requirements:
- Manual backup only (no automated scheduling)
- Separate sections for database backup vs attachment backup
- Full restore verification steps
- Uses VACUUM INTO (not file copy) for hot backups
  </action>
  <verify>
- BACKUP.md exists at project root
- Contains "VACUUM INTO" for safe backups
- Has separate sections for database and attachment backup
- Has restore procedures with verification checklist
- At least 100 lines of documentation
  </verify>
  <done>
BACKUP.md provides comprehensive backup and restore documentation.
  </done>
</task>

</tasks>

<verification>
1. backup.ts exports functions: `grep -E "export.*function" src/lib/server/db/backup.ts`
2. BACKUP.md exists: `ls -la BACKUP.md`
3. BACKUP.md references VACUUM INTO: `grep "VACUUM INTO" BACKUP.md`
4. Type check passes: `npm run check`
</verification>

<success_criteria>
- src/lib/server/db/backup.ts exports backupDatabase and backupDatabaseAsync functions
- BACKUP.md exists at project root (not buried in README)
- BACKUP.md has separate sections for database and attachment backup
- BACKUP.md uses VACUUM INTO method (not file copy)
- BACKUP.md includes verification checklist for restores
- BACKUP.md references Docker volume names (ledger-db, ledger-attachments)
</success_criteria>

<output>
After completion, create `.planning/phases/09-mobile-deployment/09-03-SUMMARY.md`
</output>
