---
phase: 08-report-generation-data
plan: 04
type: execute
wave: 3
depends_on: [08-03]
files_modified:
  - package.json
  - src/lib/server/db/schema.ts
  - src/lib/server/db/migrate.ts
  - src/lib/server/recurring/patterns.ts
  - src/lib/server/recurring/instances.ts
  - src/routes/w/[workspace]/recurring/+page.svelte
  - src/routes/w/[workspace]/recurring/+page.server.ts
  - src/routes/w/[workspace]/transactions/+page.svelte
  - src/routes/w/[workspace]/transactions/+page.server.ts
autonomous: true

must_haves:
  truths:
    - "User can create a recurring transaction template with flexible patterns"
    - "Patterns include weekly, biweekly, monthly, quarterly, yearly, and custom intervals"
    - "Upcoming recurring instances appear as pending in the timeline"
    - "User can confirm a pending instance to create an actual transaction"
    - "Confirmed transaction is editable before saving (copy from template)"
    - "User can skip/void a single pending instance"
    - "User can delete all future instances (cancel series)"
    - "User can set optional end date for recurring series"
  artifacts:
    - path: "src/lib/server/db/schema.ts"
      provides: "recurring_templates table schema"
      contains: "recurringTemplates"
    - path: "src/lib/server/recurring/patterns.ts"
      provides: "rrule wrapper for pattern creation"
      exports: ["createRRule", "getPatternDescription"]
    - path: "src/lib/server/recurring/instances.ts"
      provides: "Generate pending instances for display"
      exports: ["getPendingInstances", "getNextOccurrence"]
    - path: "src/routes/w/[workspace]/recurring/+page.svelte"
      provides: "Recurring templates management UI"
    - path: "src/routes/w/[workspace]/recurring/+page.server.ts"
      provides: "CRUD actions for recurring templates"
      exports: ["load", "actions"]
  key_links:
    - from: "src/routes/w/[workspace]/recurring/+page.server.ts"
      to: "src/lib/server/recurring/patterns.ts"
      via: "createRRule import for pattern storage"
      pattern: "import.*createRRule"
    - from: "src/routes/w/[workspace]/transactions/+page.svelte"
      to: "pending instances"
      via: "displays pending items with confirm button"
      pattern: "pending.*confirm"
---

<objective>
Create recurring transaction system with template management, flexible patterns via rrule, pending instance display in timeline, and confirm/skip/cancel actions.

Purpose: Enable users to manage predictable recurring income/expenses (rent, subscriptions, regular clients) with templates that generate upcoming instances for manual confirmation.

Output: Recurring page for template management, pending instances shown in transactions timeline, confirm flow creates editable transaction copy.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-report-generation-data/08-CONTEXT.md
@.planning/phases/08-report-generation-data/08-RESEARCH.md

# Relevant existing files
@src/lib/server/db/schema.ts
@src/lib/server/db/migrate.ts
@src/routes/w/[workspace]/transactions/+page.svelte
@src/routes/w/[workspace]/transactions/+page.server.ts
@src/routes/w/[workspace]/transactions/new/+page.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install rrule and create recurring schema</name>
  <files>package.json, src/lib/server/db/schema.ts, src/lib/server/db/migrate.ts</files>
  <action>
Install rrule:
```bash
npm install rrule
```
Note: rrule includes TypeScript types.

Add `recurring_templates` table to schema.ts:

```typescript
/**
 * Recurring transaction templates
 * Stores the pattern and template data for generating pending instances
 */
export const recurringTemplates = sqliteTable('recurring_templates', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  publicId: text('public_id').notNull().unique(), // UUID for URLs

  // Template transaction data
  type: text('type', { enum: ['income', 'expense'] }).notNull(),
  amountCents: integer('amount_cents').notNull(),
  payee: text('payee').notNull(),
  description: text('description'),
  paymentMethod: text('payment_method', { enum: ['cash', 'card', 'check'] }).notNull(),

  // Recurrence pattern (rrule string)
  rruleString: text('rrule_string').notNull(), // Stored rrule
  patternDescription: text('pattern_description').notNull(), // Human-readable "Every 2 weeks"

  // Dates
  startDate: text('start_date').notNull(), // YYYY-MM-DD first occurrence
  endDate: text('end_date'), // YYYY-MM-DD optional end date (null = indefinite)

  // Status
  active: integer('active', { mode: 'boolean' }).default(true).notNull(),

  // Timestamps
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`).notNull()
});

export type RecurringTemplate = typeof recurringTemplates.$inferSelect;
export type NewRecurringTemplate = typeof recurringTemplates.$inferInsert;
```

Add `recurring_template_tags` junction table:

```typescript
/**
 * Tags for recurring templates (mirrors transactionTags pattern)
 */
export const recurringTemplateTags = sqliteTable('recurring_template_tags', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  templateId: integer('template_id')
    .notNull()
    .references(() => recurringTemplates.id, { onDelete: 'cascade' }),
  tagId: integer('tag_id')
    .notNull()
    .references(() => tags.id, { onDelete: 'restrict' }),
  percentage: integer('percentage').notNull()
}, (table) => [
  index('recurring_template_tags_template_idx').on(table.templateId),
  index('recurring_template_tags_tag_idx').on(table.tagId)
]);

export type RecurringTemplateTag = typeof recurringTemplateTags.$inferSelect;
```

Add `skippedInstances` table to track voided/skipped occurrences:

```typescript
/**
 * Tracks skipped instances of recurring templates
 * When user skips an occurrence, record it here so it doesn't show again
 */
export const skippedInstances = sqliteTable('skipped_instances', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  templateId: integer('template_id')
    .notNull()
    .references(() => recurringTemplates.id, { onDelete: 'cascade' }),
  date: text('date').notNull(), // YYYY-MM-DD of skipped occurrence
  skippedAt: text('skipped_at').default(sql`CURRENT_TIMESTAMP`).notNull()
}, (table) => [
  index('skipped_instances_template_date_idx').on(table.templateId, table.date)
]);
```

Add `recurringTemplateId` to transactions table:
- Optional field linking confirmed transaction back to its template
- Add after checkNumber field

Update migrate.ts:
- Add migrations for new tables (CREATE TABLE IF NOT EXISTS)
- Add migration to add recurringTemplateId column to transactions
  </action>
  <verify>
Run `npm run check` to verify TypeScript compiles.
Run dev server, navigate to workspace - migrations should run without error.
  </verify>
  <done>
rrule installed, recurring_templates/recurring_template_tags/skipped_instances tables in schema, transactions has recurringTemplateId, migrations run successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create recurring pattern utilities</name>
  <files>src/lib/server/recurring/patterns.ts, src/lib/server/recurring/instances.ts</files>
  <action>
Create `src/lib/server/recurring/patterns.ts`:

```typescript
import { RRule, Frequency } from 'rrule';

export type RecurringFrequency =
  | 'daily'
  | 'weekly'
  | 'biweekly'
  | 'monthly'
  | 'quarterly'
  | 'yearly'
  | 'custom';

export interface RecurringPattern {
  frequency: RecurringFrequency;
  interval?: number;        // For custom: every N periods
  customUnit?: 'day' | 'week' | 'month';
  dayOfWeek?: number;       // 0-6 (Mon-Sun) for weekly patterns
  dayOfMonth?: number;      // 1-31 for monthly patterns
}

/**
 * Create an RRule from pattern definition.
 */
export function createRRule(pattern: RecurringPattern, startDate: string, endDate?: string): RRule {
  // Parse start date as local date (no timezone)
  const [year, month, day] = startDate.split('-').map(Number);
  const dtstart = new Date(year, month - 1, day, 12, 0, 0); // Noon to avoid DST issues

  let freq: Frequency;
  let interval = 1;
  const options: Partial<typeof RRule.prototype.options> = {};

  switch (pattern.frequency) {
    case 'daily':
      freq = RRule.DAILY;
      break;
    case 'weekly':
      freq = RRule.WEEKLY;
      if (pattern.dayOfWeek !== undefined) {
        options.byweekday = [pattern.dayOfWeek];
      }
      break;
    case 'biweekly':
      freq = RRule.WEEKLY;
      interval = 2;
      break;
    case 'monthly':
      freq = RRule.MONTHLY;
      if (pattern.dayOfMonth !== undefined) {
        options.bymonthday = [pattern.dayOfMonth];
      }
      break;
    case 'quarterly':
      freq = RRule.MONTHLY;
      interval = 3;
      break;
    case 'yearly':
      freq = RRule.YEARLY;
      break;
    case 'custom':
      freq = pattern.customUnit === 'day' ? RRule.DAILY :
             pattern.customUnit === 'week' ? RRule.WEEKLY : RRule.MONTHLY;
      interval = pattern.interval || 1;
      break;
    default:
      freq = RRule.MONTHLY;
  }

  const ruleOptions: ConstructorParameters<typeof RRule>[0] = {
    freq,
    interval,
    dtstart,
    ...options
  };

  if (endDate) {
    const [ey, em, ed] = endDate.split('-').map(Number);
    ruleOptions.until = new Date(ey, em - 1, ed, 23, 59, 59);
  }

  return new RRule(ruleOptions);
}

/**
 * Get human-readable description of pattern.
 */
export function getPatternDescription(pattern: RecurringPattern): string {
  switch (pattern.frequency) {
    case 'daily':
      return 'Every day';
    case 'weekly':
      return 'Every week';
    case 'biweekly':
      return 'Every 2 weeks';
    case 'monthly':
      return 'Every month';
    case 'quarterly':
      return 'Every 3 months';
    case 'yearly':
      return 'Every year';
    case 'custom':
      const unit = pattern.customUnit || 'month';
      const interval = pattern.interval || 1;
      return `Every ${interval} ${unit}${interval > 1 ? 's' : ''}`;
    default:
      return 'Unknown pattern';
  }
}

/**
 * Parse pattern from stored rrule string.
 */
export function parseRRuleString(rruleString: string): RRule {
  return RRule.fromString(rruleString);
}
```

Create `src/lib/server/recurring/instances.ts`:

```typescript
import { RRule } from 'rrule';
import { parseRRuleString } from './patterns';

export interface PendingInstance {
  templateId: number;
  templatePublicId: string;
  date: string;  // YYYY-MM-DD
  type: 'income' | 'expense';
  payee: string;
  amountCents: number;
  description?: string;
  patternDescription: string;
}

/**
 * Get pending instances for a template within date range.
 * Excludes already confirmed (transactions exist) and skipped instances.
 */
export function getPendingInstances(
  rule: RRule,
  startDate: Date,
  endDate: Date,
  confirmedDates: Set<string>,
  skippedDates: Set<string>
): string[] {
  const occurrences = rule.between(startDate, endDate, true);

  return occurrences
    .map(d => d.toISOString().split('T')[0])
    .filter(date => !confirmedDates.has(date) && !skippedDates.has(date));
}

/**
 * Get next occurrence date for a template.
 */
export function getNextOccurrence(
  rruleString: string,
  confirmedDates: Set<string>,
  skippedDates: Set<string>
): string | null {
  const rule = parseRRuleString(rruleString);
  const now = new Date();
  const sixMonthsLater = new Date();
  sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);

  const pending = getPendingInstances(rule, now, sixMonthsLater, confirmedDates, skippedDates);
  return pending.length > 0 ? pending[0] : null;
}

/**
 * Get all pending instances for display in timeline.
 * Returns instances for next 3 months by default.
 */
export function getAllPendingForTimeline(
  templates: Array<{
    id: number;
    publicId: string;
    type: 'income' | 'expense';
    payee: string;
    amountCents: number;
    description?: string;
    rruleString: string;
    patternDescription: string;
    active: boolean;
  }>,
  confirmedByTemplate: Map<number, Set<string>>,
  skippedByTemplate: Map<number, Set<string>>,
  fiscalYearStart: string,
  fiscalYearEnd: string
): PendingInstance[] {
  const instances: PendingInstance[] = [];
  const startDate = new Date(fiscalYearStart);
  const endDate = new Date(fiscalYearEnd);
  const today = new Date();

  // Only show future instances (from today forward within FY)
  const effectiveStart = startDate > today ? startDate : today;

  for (const template of templates) {
    if (!template.active) continue;

    const rule = parseRRuleString(template.rruleString);
    const confirmed = confirmedByTemplate.get(template.id) || new Set();
    const skipped = skippedByTemplate.get(template.id) || new Set();

    const dates = getPendingInstances(rule, effectiveStart, endDate, confirmed, skipped);

    for (const date of dates) {
      instances.push({
        templateId: template.id,
        templatePublicId: template.publicId,
        date,
        type: template.type,
        payee: template.payee,
        amountCents: template.amountCents,
        description: template.description,
        patternDescription: template.patternDescription
      });
    }
  }

  // Sort by date
  instances.sort((a, b) => a.date.localeCompare(b.date));
  return instances;
}
```
  </action>
  <verify>
Run `npm run check` to verify TypeScript compiles with no errors.
  </verify>
  <done>
patterns.ts exports createRRule and getPatternDescription, instances.ts exports getPendingInstances and getAllPendingForTimeline.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create recurring management page and integrate with timeline</name>
  <files>src/routes/w/[workspace]/recurring/+page.svelte, src/routes/w/[workspace]/recurring/+page.server.ts, src/routes/w/[workspace]/transactions/+page.svelte, src/routes/w/[workspace]/transactions/+page.server.ts, src/routes/w/[workspace]/settings/+page.svelte</files>
  <action>
Create `src/routes/w/[workspace]/recurring/+page.server.ts`:

Load function:
- Query all recurring templates with their tags
- Query skipped instances
- Query transactions with recurringTemplateId to find confirmed dates
- Return templates list with status info

Actions:
1. `create` - Create new recurring template:
   - Generate publicId
   - Create RRule from pattern, store rruleString
   - Insert template and template tags

2. `update` - Update template:
   - Update fields, regenerate rruleString if pattern changed

3. `deactivate` - Set active=false (soft cancel)

4. `delete` - Delete template (if no confirmed transactions)

5. `skip` - Skip single instance:
   - Insert into skipped_instances

6. `confirm` - Redirect to transaction create with prefilled data:
   - Return redirect URL with query params for prefill

Create `src/routes/w/[workspace]/recurring/+page.svelte`:

Two sections:
1. **Create New Recurring** form (collapsible):
   - Type (income/expense) buttons
   - Amount input
   - Payee input
   - Tags selector
   - Pattern selector:
     - Dropdown: Daily, Weekly, Biweekly, Monthly, Quarterly, Yearly, Custom
     - For custom: interval input + unit dropdown
   - Start date (default: today)
   - End date (optional, checkbox to enable)
   - "Create Recurring" button

2. **Active Recurring** list:
   - Card per template showing:
     - Type icon + Payee + Amount
     - Pattern description (e.g., "Every month")
     - Next occurrence date
     - Tags
   - Actions: Edit, Deactivate, Delete

Update `src/routes/w/[workspace]/transactions/+page.server.ts`:

Add to load function:
- Query active recurring templates
- Calculate pending instances using getAllPendingForTimeline
- Return pendingInstances array alongside transactions

Update `src/routes/w/[workspace]/transactions/+page.svelte`:

Display pending instances in timeline:
- Group pending with transactions by date
- Pending instances have distinct styling:
  - Dashed border instead of solid
  - Gray/muted text
  - "Pending" badge
  - "Confirm" and "Skip" action buttons
- Confirm button: navigates to /transactions/new with prefill query params
- Skip button: calls ?/skip action

Prefill pattern for confirmed recurring:
- URL: /w/{workspace}/transactions/new?from_recurring={templatePublicId}&date={date}
- Transaction new page reads query params and prefills form
- After save, transaction gets recurringTemplateId set

Update `src/routes/w/[workspace]/settings/+page.svelte`:
- Add link to Recurring page in a new section or as link in Data section
  </action>
  <verify>
1. Run dev server
2. Navigate to /w/{workspace}/recurring
3. Create a recurring template (e.g., monthly expense)
4. Go to transactions page
5. See pending instance appear in timeline
6. Click "Confirm" - goes to new transaction form prefilled
7. Complete transaction - it shows as confirmed (solid, not dashed)
8. Create another recurring, click "Skip" - instance disappears
9. On recurring page, deactivate template - pending instances disappear
  </verify>
  <done>
Recurring page allows CRUD on templates, transactions page shows pending instances, confirm creates transaction, skip hides instance.
  </done>
</task>

</tasks>

<verification>
1. `npm run check` passes
2. Recurring templates can be created with all pattern types
3. Pending instances appear in transactions timeline within current fiscal year
4. Pending instances show as distinct (dashed, muted) from real transactions
5. Confirming creates real transaction with prefilled data
6. Skipping hides the specific date instance
7. Deactivating template stops showing future pending instances
8. End date on template correctly limits occurrences
9. Transactions confirmed from recurring have recurringTemplateId set
</verification>

<success_criteria>
- User can create recurring templates with flexible patterns
- Patterns include: daily, weekly, biweekly, monthly, quarterly, yearly, custom intervals
- Upcoming occurrences appear as pending in transactions timeline
- Pending instances have visual distinction (dashed, muted)
- Confirming a pending opens transaction form with prefilled values
- Confirmed transaction is editable before saving
- User can skip individual occurrences
- User can deactivate template to cancel future occurrences
- Optional end date limits when recurrence stops
</success_criteria>

<output>
After completion, create `.planning/phases/08-report-generation-data/08-04-SUMMARY.md`
</output>
