---
phase: 08-report-generation-data
plan: 03
type: execute
wave: 2
depends_on: [08-02]
files_modified:
  - src/lib/server/import/csv-parser.ts
  - src/lib/server/import/date-detector.ts
  - src/routes/w/[workspace]/import/+page.svelte
  - src/routes/w/[workspace]/import/+page.server.ts
  - src/routes/w/[workspace]/+layout.svelte
autonomous: true

must_haves:
  truths:
    - "User can upload a CSV file for import"
    - "User can map CSV columns to transaction fields"
    - "User sees preview of first 10-20 rows with parsed values"
    - "User sees total row count and error count before confirming"
    - "Invalid rows are skipped, valid rows are imported"
    - "Unknown tags prompt user to create new or map to existing"
    - "Import shows summary of what was imported and what was skipped"
  artifacts:
    - path: "src/lib/server/import/csv-parser.ts"
      provides: "CSV parsing and preview generation"
      exports: ["parseCSVPreview", "parseCSVFull"]
    - path: "src/lib/server/import/date-detector.ts"
      provides: "Multi-format date parsing"
      exports: ["parseDate", "DATE_FORMATS"]
    - path: "src/routes/w/[workspace]/import/+page.svelte"
      provides: "Import wizard UI with column mapping and preview"
    - path: "src/routes/w/[workspace]/import/+page.server.ts"
      provides: "Form actions for upload, preview, and import"
      exports: ["actions"]
  key_links:
    - from: "src/routes/w/[workspace]/import/+page.server.ts"
      to: "src/lib/server/import/csv-parser.ts"
      via: "parseCSVPreview and parseCSVFull imports"
      pattern: "import.*parseCSV"
    - from: "src/routes/w/[workspace]/import/+page.server.ts"
      to: "prisma.transaction"
      via: "database insert for imported transactions"
      pattern: "db\\.insert\\(transactions\\)"
---

<objective>
Create CSV import workflow with file upload, column mapping, preview with validation, tag handling for unknowns, and batch import with skip-invalid behavior.

Purpose: Enable users to import historical transaction data from spreadsheets or other accounting software, with full control over field mapping and validation.

Output: Import page accessible from Settings with complete wizard flow: Upload -> Map Columns -> Preview -> Confirm -> Results.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-report-generation-data/08-CONTEXT.md
@.planning/phases/08-report-generation-data/08-RESEARCH.md

# Relevant existing files
@src/lib/server/db/schema.ts
@src/routes/w/[workspace]/transactions/new/+page.server.ts
@src/routes/w/[workspace]/settings/+page.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSV parsing and date detection utilities</name>
  <files>src/lib/server/import/csv-parser.ts, src/lib/server/import/date-detector.ts</files>
  <action>
Create `src/lib/server/import/date-detector.ts`:

```typescript
import { parse, isValid, format } from 'date-fns';

// Date formats to try, in order of likelihood for US users
export const DATE_FORMATS = [
  'yyyy-MM-dd',      // ISO: 2026-01-15
  'MM/dd/yyyy',      // US: 01/15/2026
  'M/d/yyyy',        // US short: 1/15/2026
  'MM-dd-yyyy',      // US with dashes
  'M-d-yyyy',        // US short with dashes
  'dd/MM/yyyy',      // European: 15/01/2026
  'dd-MM-yyyy',      // European with dashes
  'MMM d, yyyy',     // Text: Jan 15, 2026
  'MMMM d, yyyy',    // Full text: January 15, 2026
  'yyyy/MM/dd',      // Asian: 2026/01/15
];

/**
 * Attempt to parse a date string using multiple formats.
 * Returns YYYY-MM-DD format or null if unparseable.
 */
export function parseDate(dateStr: string): string | null {
  const trimmed = dateStr.trim();
  if (!trimmed) return null;

  for (const fmt of DATE_FORMATS) {
    try {
      const parsed = parse(trimmed, fmt, new Date());
      if (isValid(parsed)) {
        return format(parsed, 'yyyy-MM-dd');
      }
    } catch {
      // Try next format
    }
  }
  return null;
}

/**
 * Detect the most likely date format from a sample of date strings.
 * Returns the format string or null if no consistent format found.
 */
export function detectDateFormat(samples: string[]): string | null {
  const formatCounts = new Map<string, number>();

  for (const sample of samples) {
    for (const fmt of DATE_FORMATS) {
      try {
        const parsed = parse(sample.trim(), fmt, new Date());
        if (isValid(parsed)) {
          formatCounts.set(fmt, (formatCounts.get(fmt) || 0) + 1);
          break; // Use first matching format for this sample
        }
      } catch {
        // Try next format
      }
    }
  }

  // Return format with highest count
  let bestFormat: string | null = null;
  let bestCount = 0;
  for (const [fmt, count] of formatCounts) {
    if (count > bestCount) {
      bestCount = count;
      bestFormat = fmt;
    }
  }

  return bestFormat;
}
```

Create `src/lib/server/import/csv-parser.ts`:

```typescript
import Papa from 'papaparse';
import { parseDate } from './date-detector';

export interface ParsedRow {
  rowNumber: number;
  data: Record<string, string>;
  errors: string[];
}

export interface CSVPreviewResult {
  headers: string[];
  preview: ParsedRow[];
  totalRows: number;
  parseErrors: string[];
}

export interface ColumnMapping {
  date?: string;
  type?: string;
  payee?: string;
  amount?: string;
  description?: string;
  tags?: string;
  paymentMethod?: string;
  checkNumber?: string;
}

export interface ValidatedTransaction {
  date: string;
  type: 'income' | 'expense';
  payee: string;
  amountCents: number;
  description?: string;
  tags: string[];
  paymentMethod: 'cash' | 'card' | 'check';
  checkNumber?: string;
}

export interface ValidationResult {
  valid: ValidatedTransaction[];
  invalid: Array<{ rowNumber: number; errors: string[] }>;
  unknownTags: string[];
}

/**
 * Parse CSV and return preview with headers and first N rows.
 */
export function parseCSVPreview(csvText: string, previewRows = 20): CSVPreviewResult {
  const result = Papa.parse(csvText, {
    header: true,
    skipEmptyLines: 'greedy',
    transformHeader: (h) => h.trim()
  });

  const headers = result.meta.fields || [];
  const allData = result.data as Record<string, string>[];

  const preview: ParsedRow[] = allData.slice(0, previewRows).map((row, index) => ({
    rowNumber: index + 2, // +2 for 1-based and header row
    data: row,
    errors: []
  }));

  return {
    headers,
    preview,
    totalRows: allData.length,
    parseErrors: result.errors.map(e => `Row ${e.row}: ${e.message}`)
  };
}

/**
 * Parse and validate full CSV with column mapping.
 * Returns validated transactions and invalid rows.
 */
export function validateCSVWithMapping(
  csvText: string,
  mapping: ColumnMapping,
  existingTags: string[]
): ValidationResult {
  const result = Papa.parse(csvText, {
    header: true,
    skipEmptyLines: 'greedy',
    transformHeader: (h) => h.trim()
  });

  const allData = result.data as Record<string, string>[];
  const valid: ValidatedTransaction[] = [];
  const invalid: Array<{ rowNumber: number; errors: string[] }> = [];
  const unknownTagsSet = new Set<string>();
  const existingTagsLower = new Set(existingTags.map(t => t.toLowerCase()));

  for (let i = 0; i < allData.length; i++) {
    const row = allData[i];
    const rowNumber = i + 2; // 1-based + header
    const errors: string[] = [];

    // Parse date
    const dateRaw = mapping.date ? row[mapping.date] : '';
    const date = parseDate(dateRaw);
    if (!date) {
      errors.push(`Invalid date: "${dateRaw}"`);
    }

    // Parse type
    const typeRaw = mapping.type ? row[mapping.type]?.toLowerCase().trim() : '';
    let type: 'income' | 'expense' | null = null;
    if (typeRaw === 'income' || typeRaw === 'expense') {
      type = typeRaw;
    } else if (typeRaw === 'in' || typeRaw === 'revenue' || typeRaw === 'sale') {
      type = 'income';
    } else if (typeRaw === 'out' || typeRaw === 'cost' || typeRaw === 'purchase' || typeRaw === 'exp') {
      type = 'expense';
    } else {
      errors.push(`Invalid type: "${typeRaw}" (expected income or expense)`);
    }

    // Parse payee
    const payee = mapping.payee ? row[mapping.payee]?.trim() : '';
    if (!payee) {
      errors.push('Payee is required');
    }

    // Parse amount
    const amountRaw = mapping.amount ? row[mapping.amount] : '';
    const amountCents = parseAmount(amountRaw);
    if (amountCents === null) {
      errors.push(`Invalid amount: "${amountRaw}"`);
    }

    // Parse payment method
    const pmRaw = mapping.paymentMethod ? row[mapping.paymentMethod]?.toLowerCase().trim() : 'card';
    let paymentMethod: 'cash' | 'card' | 'check' = 'card';
    if (pmRaw === 'cash') paymentMethod = 'cash';
    else if (pmRaw === 'check' || pmRaw === 'cheque') paymentMethod = 'check';
    else paymentMethod = 'card';

    // Parse check number
    const checkNumber = mapping.checkNumber ? row[mapping.checkNumber]?.trim() : undefined;

    // Parse description
    const description = mapping.description ? row[mapping.description]?.trim() : undefined;

    // Parse tags
    const tagsRaw = mapping.tags ? row[mapping.tags] : '';
    const tags = tagsRaw
      .split(/[,;]/)
      .map(t => t.trim())
      .filter(t => t.length > 0);

    // Check for unknown tags
    for (const tag of tags) {
      if (!existingTagsLower.has(tag.toLowerCase())) {
        unknownTagsSet.add(tag);
      }
    }

    if (errors.length > 0) {
      invalid.push({ rowNumber, errors });
    } else if (date && type && payee && amountCents !== null) {
      valid.push({
        date,
        type,
        payee,
        amountCents,
        description: description || undefined,
        tags,
        paymentMethod,
        checkNumber: checkNumber || undefined
      });
    }
  }

  return {
    valid,
    invalid,
    unknownTags: Array.from(unknownTagsSet)
  };
}

/**
 * Parse amount string to cents.
 * Handles: $1,234.56, 1234.56, -$50.00, (50.00) for negatives
 */
function parseAmount(amountStr: string): number | null {
  if (!amountStr) return null;

  let str = amountStr.trim();
  let negative = false;

  // Handle parentheses for negative (accounting format)
  if (str.startsWith('(') && str.endsWith(')')) {
    negative = true;
    str = str.slice(1, -1);
  }

  // Handle leading minus
  if (str.startsWith('-')) {
    negative = true;
    str = str.slice(1);
  }

  // Remove currency symbols and commas
  str = str.replace(/[$,]/g, '');

  const num = parseFloat(str);
  if (isNaN(num)) return null;

  const cents = Math.round(num * 100);
  return negative ? -cents : cents;
}
```
  </action>
  <verify>
Run `npm run check` to verify TypeScript compiles with no errors.
  </verify>
  <done>
date-detector.ts exports parseDate and detectDateFormat, csv-parser.ts exports parseCSVPreview and validateCSVWithMapping with proper typing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create import page with wizard flow</name>
  <files>src/routes/w/[workspace]/import/+page.svelte, src/routes/w/[workspace]/import/+page.server.ts</files>
  <action>
Create `src/routes/w/[workspace]/import/+page.server.ts`:

Load function:
- Load existing tags for mapping unknown tags
- Return { tags: string[] }

Actions:
1. `preview` action:
   - Receive FormData with file
   - Read file text
   - Call parseCSVPreview
   - Store CSV text in a temp mechanism (return in response for client to hold)
   - Return preview result

2. `import` action:
   - Receive: csvText, mapping (JSON), tagMappings (JSON for unknown->existing map), createTags (JSON array)
   - Get existing tags
   - Create any new tags from createTags array
   - Call validateCSVWithMapping
   - For each valid transaction:
     - Generate publicId
     - Insert transaction
     - Create transactionTags with 100% allocation (single tag) or equal split (multiple)
     - Insert history record (created)
   - Return { imported: number, skipped: number, skippedRows: [...] }

Create `src/routes/w/[workspace]/import/+page.svelte`:

Multi-step wizard with state management:

Step 1 - Upload:
- File input for CSV
- "Upload & Preview" button submits to ?/preview
- Show parse errors if any

Step 2 - Column Mapping:
- Detected headers in dropdown selects
- Required fields: Date, Type, Payee, Amount
- Optional: Description, Tags, Payment Method, Check Number
- Auto-suggest based on header names (date, type, payee, amount, desc, etc.)
- "Preview with Mapping" button

Step 3 - Preview & Validation:
- Table showing first 10-20 rows with mapped values
- Show total count, valid count, error count
- List validation errors by row
- If unknown tags exist, show mapping UI:
  - For each unknown tag: dropdown to map to existing OR checkbox to create new
- "Import Valid Rows" button

Step 4 - Results:
- Success message: "Imported X transactions"
- If skipped: "Skipped Y rows due to errors"
- Expandable list of skipped rows with reasons
- "View Transactions" link to transactions page
- "Import Another" button to reset wizard

UI Structure:
```svelte
<script lang="ts">
  let step = $state<'upload' | 'mapping' | 'preview' | 'results'>('upload');
  let csvText = $state('');
  let previewData = $state<PreviewResult | null>(null);
  let mapping = $state<ColumnMapping>({});
  let validationResult = $state<ValidationResult | null>(null);
  let importResult = $state<ImportResult | null>(null);
  // ... rest of state
</script>

{#if step === 'upload'}
  <!-- File upload form -->
{:else if step === 'mapping'}
  <!-- Column mapping dropdowns -->
{:else if step === 'preview'}
  <!-- Preview table and tag handling -->
{:else if step === 'results'}
  <!-- Import results summary -->
{/if}
```

Use consistent card styling from Settings page.
  </action>
  <verify>
1. Run dev server
2. Navigate to /w/{workspace}/import
3. Upload a test CSV file
4. Map columns to fields
5. Preview shows parsed data with validation
6. Complete import
7. Check transactions page - imported transactions appear
  </verify>
  <done>
Import page has complete 4-step wizard: Upload -> Map -> Preview -> Results, with tag handling for unknowns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add import link to Settings page and navigation</name>
  <files>src/routes/w/[workspace]/settings/+page.svelte, src/routes/w/[workspace]/+layout.svelte</files>
  <action>
Update Settings page Data Export section to include Import:
- Rename section to "Data Import & Export"
- Add separator between import and export
- Add Import row with description and link/button to /w/{workspace}/import

```svelte
<!-- Import -->
<div class="flex items-center justify-between py-2">
  <div>
    <h3 class="text-sm font-medium text-gray-900">Import Transactions</h3>
    <p class="text-xs text-gray-500">Import transactions from CSV file</p>
  </div>
  <a
    href="/w/{workspaceId}/import"
    class="inline-flex items-center gap-1.5 rounded-lg bg-blue-600 px-3 py-1.5 text-sm font-medium text-white hover:bg-blue-700"
  >
    <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
    </svg>
    Import CSV
  </a>
</div>
```

Note: Do NOT add to main navigation tabs - Import is a one-time/occasional action, accessed via Settings.
  </action>
  <verify>
1. Navigate to Settings page
2. Data Import & Export section shows Import row
3. Click "Import CSV" navigates to import page
4. Can complete full import flow and return to Settings
  </verify>
  <done>
Settings page has Import link, import accessible and functional, full wizard flow works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `npm run check` passes
2. CSV upload accepts .csv files
3. Column mapping correctly identifies date, type, payee, amount
4. Preview shows first 20 rows with validation status
5. Unknown tags are surfaced with option to create or map
6. Import creates transactions with correct data
7. Invalid rows are skipped with clear error messages
8. Import history is tracked (transaction created records)
9. Settings page links to import
</verification>

<success_criteria>
- User can upload CSV and see column headers
- User can map columns to transaction fields
- Preview shows parsed dates, amounts, and validates required fields
- Unknown tags prompt user: create new or map to existing
- Clicking "Import" creates transactions for valid rows
- Invalid rows are skipped and reported (row number + error)
- Results page shows import summary
- Imported transactions appear in transactions list
</success_criteria>

<output>
After completion, create `.planning/phases/08-report-generation-data/08-03-SUMMARY.md`
</output>
